int pipe(int pipefd[2]);
作用：创建并打开管道
pipefd[0]:读
pipefd[1]:写
retval: success 0
        error   -1,errno

管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，因为父子进程共享文件描述符。调用pipe系统函数即可创建一个管道。
一，作用：
    1，管道实质是一个伪文件，实际为内核的缓冲区（4K）
    2，采用循环队列实现，故只能一端写一端读。
    3，由两个文件描述符引用，一个表示读端，一个表示写端，数据由写端流向读端
    4，管道(两根)采用半双工通讯。
二，管道的读写行为
    1，读管道   
        #1管道有数据，read返回实际读到的字节数
        #2管道无数据：
                    （1）管道的写端全部关闭，read返回0（类似读到文件末尾）
                    （2）管道的写端没有全部被关闭，read阻塞等待，因为可能会有数据从写端写入， 此时会让出cpu
    2,写管道
        #1管道的读端全部关闭，进程异常终止（SIGPIPE导致）
        #2管道的读端没有全部关闭:
                    (1)管道已满，write阻塞（实际上管道满后，内核会给这个管道缓冲区扩容）
                    （2）管道未满，write将数据写入管道
                    
---------------------------------------------------------------------------------
命名管道
    创建出的管道，当文件使就行
    命名管道 (FIFO) 的规则：

    open(path, O_RDONLY) → 若 没有 任何进程以 写 打开同一 FIFO，则阻塞；

    open(path, O_WRONLY) → 若 没有 任何进程以 读 打开同一 FIFO，则阻塞；

    加 O_NONBLOCK 可以让 open() 立即返回错误 ENXIO（写端）或成功但读返回 0（读端）。
两种实现方式：1，命令mkfifo 管道名
            2，int mkfifo(const char *pathname, mode_t mode);
                #param
                    pathname 管道名
                    mode 权限（mode & ~umask）
                #retval
                    success 0
                    error -1，errno


